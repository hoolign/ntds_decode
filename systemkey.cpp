/**
 *  The MIT License:
 *
 *  Copyright (c) 2009, 2010, 2013 Kevin Devine
 *
 *  Permission is hereby granted,  free of charge,  to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"),  to deal
 *  in the Software without restriction,  including without limitation the rights
 *  to use,  copy,  modify,  merge,  publish,  distribute,  sublicense,  and/or sell
 *  copies of the Software,  and to permit persons to whom the Software is
 *  furnished to do so,  subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS",  WITHOUT WARRANTY OF ANY KIND,  EXPRESS OR
 *  IMPLIED,  INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,  DAMAGES OR OTHER
 *  LIABILITY,  WHETHER IN AN ACTION OF CONTRACT,  TORT OR OTHERWISE,  ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */

#include "SystemKey.h"

SystemKey::SystemKey () {
  ZeroMemory(key, SYSTEM_KEY_LEN);
  
  bLoaded  = FALSE;
  bRestore = FALSE;
  bBackup  = FALSE;
  dwError  = ERROR_SUCCESS;
}

/**
 *
 *  Generate System key from pass phrase -> level 2
 *  Derives 128-bit value from MD5
 *
 */
BOOL SystemKey::SetFromPassword (std::wstring pwd) {
  HCRYPTPROV hProv;
  HCRYPTHASH hHash;

  if (CryptAcquireContext (&hProv, NULL, NULL, PROV_RSA_FULL,
      CRYPT_VERIFYCONTEXT)) {
    if (CryptCreateHash (hProv, CALG_MD5, 0, 0, &hHash)) {
      if (CryptHashData (hHash, (PBYTE)pwd.c_str(),
          pwd.length() * sizeof(wchar_t), 0)) {

        DWORD dwHashLen = SYSTEM_KEY_LEN;
        CryptGetHashParam (hHash, HP_HASHVAL, key, &dwHashLen, 0);
        dwError = GetLastError();
      }
      CryptDestroyHash (hHash);
    } else {
      dwError = GetLastError ();
    }
    CryptReleaseContext (hProv, 0);
  } else {
    dwError = GetLastError ();
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 *  Get random 16-byte system key from file.
 *  Default location is A:\Startkey.key
 *
 */
BOOL SystemKey::SetFromFile (std::wstring fname) {
  HANDLE hFile;

  hFile = CreateFile (fname.c_str(), GENERIC_READ, FILE_SHARE_READ,
      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

  if (hFile != INVALID_HANDLE_VALUE) {
    DWORD dwRead = 0;
    ReadFile (hFile, key, SYSTEM_KEY_LEN, &dwRead, NULL);
    dwError = GetLastError ();
    CloseHandle (hFile);
  } else {
    dwError = GetLastError ();
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 *  Reads DWORD value of subkey "Default" in rootkey 
 *    "HKEY_LOCAL_MACHINE\SYSTEM\Select"
 *
 *  All entries are:
 *
 *    Current
 *    Default
 *    Failed
 *    LastKnownGood
 *
 */
DWORD SystemKey::GetSelect (VOID) {
  DWORD dwSize = sizeof (DWORD);
  HKEY hSubKey;
  
  dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, (regFile + L"\\Select").c_str(),
      0, KEY_QUERY_VALUE, &hSubKey);

  if (dwError == ERROR_SUCCESS) {
    dwError = RegQueryValueEx (hSubKey, L"Default", NULL, NULL,
        reinterpret_cast<BYTE*>(&dwSelect), &dwSize);
    RegCloseKey (hSubKey);
  }
  return dwSelect;
}

/**
 *
 *  Query SecureBoot value at System\\CurrentControlSet\\Control\\Lsa
 *
 *  SystemKey levels were verified with XP Professional
 *
 *    0 - Not enabled
 *    1 - Random key generated by OS,  stored in registry,  default on all OS since windows 2000
 *    2 - Derived from password chosen by administrator,  stored in administrators brain ;-)
 *    3 - Random key generated by OS,  stored on floppy disk
 *
 */
DWORD SystemKey::AuthType (VOID) {
  DWORD dwSize = sizeof (DWORD);
  HKEY hSubKey;

  GetSelect();

  std::wstring path = regFile + L"\\ControlSet"
      + format<std::wstring, int>(dwSelect, 3) + L"\\Control\\Lsa";

  dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, path.c_str(), 0, KEY_QUERY_VALUE, &hSubKey);

  if (dwError == ERROR_SUCCESS) {
    dwError = RegQueryValueEx (hSubKey, L"SecureBoot", NULL, NULL,
        reinterpret_cast<BYTE*>(&dwKeyType), &dwSize);
    RegCloseKey (hSubKey);
  } else {
    wprintf (L"\nRegOpenKeyEx(%s) failed with %i", path.c_str(), dwError);
  }
  return dwKeyType;
}

/**
 *
 *  Query class values of subkeys at:
 *  HKEY_LOCAL_MACHINE\System\ControlSet00X\Control\Lsa
 *
 */
BOOL SystemKey::SetFromRegistry (VOID) {
  std::wstring subkeys[4] = { L"JD", L"Skew1", L"GBG", L"Data" };
  std::wstring path;

  // shuffle bytes found in xp SystemKey binary
  BYTE xp[16] =  { 0x08, 0x05, 0x04, 0x02,
                   0x0b, 0x09, 0x0d, 0x03,
                   0x00, 0x06, 0x01, 0x0c,
                   0x0e, 0x0a, 0x0f, 0x07 };

  BYTE result[16] = { 0 };
  PBYTE p = result;

  // for each subkey
  for (size_t i = 0;i < sizeof(subkeys) / sizeof(std::wstring);i++) {
    HKEY hSubKey;

    path = regFile + L"\\ControlSet" + format<std::wstring, int>(dwSelect, 3)
        + L"\\Control\\Lsa\\" + subkeys[i];

    dwError = RegOpenKeyEx (HKEY_LOCAL_MACHINE, path.c_str(), 0, KEY_QUERY_VALUE, &hSubKey);

    if (dwError == ERROR_SUCCESS) {
      wchar_t classInfo[MAX_PATH];
      DWORD cClass = MAX_PATH;

      dwError = RegQueryInfoKey (hSubKey, classInfo, &cClass, NULL, NULL,
          NULL, NULL, NULL, NULL, NULL, NULL, NULL);

      if (dwError == ERROR_SUCCESS) {
        for (int j = 0; j < 4; j++) {
          *p++ = convert<int>(std::hex,
              std::wstring(&classInfo[j*2]).substr(0, 2));
        }
      } else {
        wprintf (L"\nRegQueryInfoKey() failed with %i", dwError);
      }
    } else {
      wprintf (L"\nRegOpenKeyEx(%s) failed with %i", path.c_str(), dwError);
    }
    RegCloseKey (hSubKey);
  }

  if (p - result == SYSTEM_KEY_LEN) {
    for (int i = 0; i < SYSTEM_KEY_LEN; i++) {
      key[i] = result[ xp[i] ];
    }
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 *  Load SYSTEM hive to memory
 *  Returns TRUE or FALSE
 *
 */
BOOL SystemKey::Load (std::wstring fname) {
  UnLoad();
  
  if (!bRestore) {
    bRestore = SetPrivilege (L"SeRestorePrivilege", TRUE);
  }
  
  if (bRestore) {
    dprintf("\nChecking %s", std::string(fname.begin(), fname.end()).c_str());
    DWORD dwAttr = GetFileAttributes (fname.c_str());
    if (dwAttr != INVALID_FILE_ATTRIBUTES) {
      dwError = RegLoadKey (HKEY_LOCAL_MACHINE, L"$$_SYSTEM", fname.c_str());
      if (dwError == ERROR_SUCCESS) {
        regFile = L"$$_SYSTEM";
        bLoaded = TRUE;
      }
    } else {
      dwError = GetLastError ();
    }
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 *  UnLoad SYSTEM hive from memory
 *  Returns TRUE or FALSE
 *
 */
BOOL SystemKey::UnLoad (void) {
  if (!bLoaded) {
    return TRUE;
  }
  dwError = RegUnLoadKey (HKEY_LOCAL_MACHINE, regFile.c_str());
  if (dwError == ERROR_SUCCESS) {
    regFile.clear();
    bLoaded = FALSE;
  }
  return dwError == ERROR_SUCCESS;
}

/**
 *
 *  Query class values of subkeys at 
 *  HKEY_LOCAL_MACHINE\System\ControlSet00X\Control\Lsa
 *
 */
BOOL SystemKey::SetKey (std::wstring param) {
  switch (dwKeyType) {
    case AUTH_REGISTRY : {
      return SetFromRegistry ();
    }
    case AUTH_PASSWORD : {
      return SetFromPassword (param);
    }
    case AUTH_FILE : {
      return SetFromFile (param);
    }
    default : {
      return SetFromRegistry ();
    }
  }
}

DWORD SystemKey::GetKey(PBYTE pKey) {
  if (pKey != NULL) {
    memcpy (pKey, key, SYSTEM_KEY_LEN);
  }
  return SYSTEM_KEY_LEN;
}


/**
 *
 *  Enables or disables a named privilege in token
 *
 *  Returns TRUE or FALSE
 *
 */
BOOL SystemKey::SetPrivilege (wchar_t szPrivilege[], BOOL bEnable) {
  HANDLE hToken;
  BOOL bResult;
  
  bResult = OpenProcessToken (GetCurrentProcess(), 
    TOKEN_ADJUST_PRIVILEGES, &hToken);
  
  if (bResult) {
    LUID luid;
    bResult = LookupPrivilegeValue (NULL, szPrivilege, &luid);
    if (bResult) {
      TOKEN_PRIVILEGES tp;
      
      tp.PrivilegeCount           = 1;
      tp.Privileges[0].Luid       = luid;
      tp.Privileges[0].Attributes = (bEnable) ? SE_PRIVILEGE_ENABLED : 0;

      AdjustTokenPrivileges (hToken, FALSE, &tp, 0, NULL, NULL);
      dwError = GetLastError ();
    } else {
      dwError = GetLastError ();
    }
    CloseHandle (hToken);
  } else {
    dwError = GetLastError ();
  }
  return dwError == ERROR_SUCCESS;
}

